ğ—¨ğ—»ğ—±ğ—²ğ—¿ğ˜€ğ˜ğ—®ğ—»ğ—±ğ—¶ğ—»ğ—´ ğ—ğ˜‚ğ—¯ğ—²ğ—¿ğ—»ğ—²ğ˜ğ—²ğ˜€ ğ—¦ğ—²ğ—¿ğ˜ƒğ—¶ğ—°ğ—² ğ—”ğ—°ğ—°ğ—¼ğ˜‚ğ—»ğ˜ğ˜€ (ğ—¦ğ—”ğ˜€)

In Kubernetes, pods are like applications running in your cluster. But how do they securely interact with the Kubernetes API? Thatâ€™s where ğ—¦ğ—²ğ—¿ğ˜ƒğ—¶ğ—°ğ—² ğ—”ğ—°ğ—°ğ—¼ğ˜‚ğ—»ğ˜ğ˜€ come in.

ğ—ªğ—µğ—®ğ˜ ğ—¶ğ˜€ ğ—® ğ—¦ğ—²ğ—¿ğ˜ƒğ—¶ğ—°ğ—² ğ—”ğ—°ğ—°ğ—¼ğ˜‚ğ—»ğ˜?

* Itâ€™s a ğ—ğ˜‚ğ—¯ğ—²ğ—¿ğ—»ğ—²ğ˜ğ—²ğ˜€ ğ—¶ğ—±ğ—²ğ—»ğ˜ğ—¶ğ˜ğ˜† ğ—³ğ—¼ğ—¿ ğ—½ğ—¼ğ—±ğ˜€, not humans.
* Each Service Account has a ğ˜ğ—¼ğ—¸ğ—²ğ—», automatically mounted inside the pod for authentication.
* Pods use this token to interact with the Kubernetes API safely.

ğ—ªğ—µğ˜† ğ˜‚ğ˜€ğ—² ğ—® ğ—¦ğ—²ğ—¿ğ˜ƒğ—¶ğ—°ğ—² ğ—”ğ—°ğ—°ğ—¼ğ˜‚ğ—»ğ˜?

* ğ—¦ğ—²ğ—°ğ˜‚ğ—¿ğ—² ğ—®ğ—°ğ—°ğ—²ğ˜€ğ˜€: Grant only the permissions a pod needs.
* ğ—œğ˜€ğ—¼ğ—¹ğ—®ğ˜ğ—¶ğ—¼ğ—»: Different pods can have different identities.
* ğ—¥ğ—•ğ—”ğ—– ğ—¶ğ—»ğ˜ğ—²ğ—´ğ—¿ğ—®ğ˜ğ—¶ğ—¼ğ—»: Connect Service Accounts to Roles/RoleBindings to control what pods can do.

ğ—¤ğ˜‚ğ—¶ğ—°ğ—¸ ğ—˜ğ˜…ğ—®ğ—ºğ—½ğ—¹ğ—²:
apiVersion: v1
kind: ServiceAccount
metadata:
 name: shopmate-sa
 namespace: shopmate

* Pod uses it via ğ˜´ğ˜¦ğ˜³ğ˜·ğ˜ªğ˜¤ğ˜¦ğ˜ˆğ˜¤ğ˜¤ğ˜°ğ˜¶ğ˜¯ğ˜µğ˜•ğ˜¢ğ˜®ğ˜¦: ğ˜´ğ˜©ğ˜°ğ˜±ğ˜®ğ˜¢ğ˜µğ˜¦-ğ˜´ğ˜¢.
* Role + RoleBinding define exactly ğ˜„ğ—µğ—®ğ˜ ğ˜ğ—µğ—¶ğ˜€ ğ—½ğ—¼ğ—± ğ—°ğ—®ğ—» ğ—®ğ—°ğ—°ğ—²ğ˜€ğ˜€.

ğŸ’¡ğ—§ğ—¶ğ—½: Even if you donâ€™t create a custom SA, every pod uses the default Service Account. But for production workloads, custom Service Accounts are best practice.

Service Accounts = Pod identity
Role = What the pod can do
RoleBinding = Connect identity to permissions

