ğ—›ğ—¼ğ˜„ ğ—£ğ—¼ğ—±ğ˜€ ğ—–ğ—®ğ—» ğ—¥ğ˜‚ğ—» ğ—˜ğ˜ƒğ—²ğ—» ğ—ªğ—¶ğ˜ğ—µğ—¼ğ˜‚ğ˜ ğ—® ğ—–ğ—¹ğ˜‚ğ˜€ğ˜ğ—²ğ—¿(ğ—¦ğ˜ğ—®ğ˜ğ—¶ğ—° ğ—£ğ—¼ğ—±ğ˜€)

What if there is ğ—»ğ—¼ ğ—ğ˜‚ğ—¯ğ—²ğ—¿ğ—»ğ—²ğ˜ğ—²ğ˜€ ğ—°ğ—¹ğ˜‚ğ˜€ğ˜ğ—²ğ—¿?
No kube-apiserver. No kubectl.
Can pods still run?

Yes. And this is why ğ˜€ğ˜ğ—®ğ˜ğ—¶ğ—° ğ—½ğ—¼ğ—±ğ˜€ exist.

Hereâ€™s the mental model:

 â€¢ kubeletâ€™s core job is to create and manage pods

 â€¢ kubelet talks directly to the container runtime (containerd)

 â€¢ even without pod details from kube-apiserver, kubelet can still read pod definitions from local files

ğ—¦ğ˜ğ—®ğ˜ğ—¶ğ—° ğ—£ğ—¼ğ—±ğ˜€

 â€¢ Pod YAMLs are placed on the node itself

 â€¢ Common path: /etc/kubernetes/manifests/

 â€¢ kubelet watches this directory

 â€¢ File added â†’ pod created, File updated â†’ pod updated, File deleted â†’ pod deleted

ğ—¡ğ—¼ ğ˜€ğ—°ğ—µğ—²ğ—±ğ˜‚ğ—¹ğ—²ğ—¿.
ğ—¡ğ—¼ ğ—°ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ğ˜€.
ğ—¡ğ—¼ ğ—”ğ—£ğ—œ ğ—°ğ—®ğ—¹ğ—¹ğ˜€ ğ—¿ğ—²ğ—¾ğ˜‚ğ—¶ğ—¿ğ—²ğ—±.

ğ—œğ—ºğ—½ğ—¼ğ—¿ğ˜ğ—®ğ—»ğ˜ ğ—¹ğ—¶ğ—ºğ—¶ğ˜ğ—®ğ˜ğ—¶ğ—¼ğ—»ğ˜€:

 â€¢ Only Pods can be created this way

 â€¢ No Deployments, ReplicaSets, Jobs, etc.

 â€¢ Because kubelet only understands pods

ğ— ğ—¶ğ—¿ğ—¿ğ—¼ğ—¿ ğ—£ğ—¼ğ—±ğ˜€ (ğ—¶ğ—ºğ—½ğ—¼ğ—¿ğ˜ğ—®ğ—»ğ˜ ğ—±ğ—²ğ˜ğ—®ğ—¶ğ—¹)

 â€¢ If kube-apiserver exists, kubelet creates a read-only mirror pod

 â€¢ Thatâ€™s why you can see static pods using kubectl

 â€¢ But you cannot edit or delete them via kubectl

Static pods exist because kubelet must keep critical pods running - even when the cluster itself isnâ€™t fully alive.
