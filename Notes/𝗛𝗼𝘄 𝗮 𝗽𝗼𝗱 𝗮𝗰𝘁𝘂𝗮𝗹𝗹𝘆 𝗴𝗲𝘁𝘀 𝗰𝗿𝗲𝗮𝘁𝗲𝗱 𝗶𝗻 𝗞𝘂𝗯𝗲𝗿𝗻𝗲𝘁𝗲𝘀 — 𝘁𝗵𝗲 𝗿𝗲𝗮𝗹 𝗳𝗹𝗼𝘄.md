ğ—›ğ—¼ğ˜„ ğ—® ğ—½ğ—¼ğ—± ğ—®ğ—°ğ˜ğ˜‚ğ—®ğ—¹ğ—¹ğ˜† ğ—´ğ—²ğ˜ğ˜€ ğ—°ğ—¿ğ—²ğ—®ğ˜ğ—²ğ—± ğ—¶ğ—» ğ—ğ˜‚ğ—¯ğ—²ğ—¿ğ—»ğ—²ğ˜ğ—²ğ˜€ â€” ğ˜ğ—µğ—² ğ—¿ğ—²ğ—®ğ—¹ ğ—³ğ—¹ğ—¼ğ˜„

Knowing individual components is fine.
Things click when you see how they move together.

This is what happens when a pod gets created.

ğŸ­. ğ—” ğ—¿ğ—²ğ—¾ğ˜‚ğ—²ğ˜€ğ˜ ğ—²ğ—»ğ˜ğ—²ğ—¿ğ˜€ ğ˜ğ—µğ—² ğ—°ğ—¹ğ˜‚ğ˜€ğ˜ğ—²ğ—¿

A user, kubectl, or a CI/CD pipeline sends a request.

Everything goes through the API server. No exceptions.

ğŸ®. ğ—”ğ—£ğ—œ ğ˜€ğ—²ğ—¿ğ˜ƒğ—²ğ—¿ ğ—¯ğ—²ğ—°ğ—¼ğ—ºğ—²ğ˜€ ğ˜ğ—µğ—² ğ—´ğ—®ğ˜ğ—²ğ—¸ğ—²ğ—²ğ—½ğ—²ğ—¿

The API server validates the request and creates a pod object.

ğŸ¯. ğ—²ğ˜ğ—°ğ—± ğ—¿ğ—²ğ—°ğ—¼ğ—¿ğ—±ğ˜€ ğ˜ğ—µğ—² ğ˜ğ—¿ğ˜‚ğ˜ğ—µ

The pod definition and cluster state are stored in etcd.

This is the single source of truth for the cluster.

ğŸ°. ğ—¦ğ—°ğ—µğ—²ğ—±ğ˜‚ğ—¹ğ—²ğ—¿ ğ—ºğ—®ğ—¸ğ—²ğ˜€ ğ˜ğ—µğ—² ğ—±ğ—²ğ—°ğ—¶ğ˜€ğ—¶ğ—¼ğ—»

The scheduler watches for pods without a node.

It evaluates available nodes and picks the best fit.

That decision is written back via the API server and stored in etcd.

ğŸ±. ğ—ğ˜‚ğ—¯ğ—²ğ—¹ğ—²ğ˜ ğ˜ğ—®ğ—¸ğ—²ğ˜€ ğ—¼ğ˜„ğ—»ğ—²ğ—¿ğ˜€ğ—µğ—¶ğ—½

The kubelet on the chosen node notices the assignment.

It reads the pod spec and tells the container runtime what to do.

ğŸ². ğ—–ğ—¼ğ—»ğ˜ğ—®ğ—¶ğ—»ğ—²ğ—¿ ğ—¿ğ˜‚ğ—»ğ˜ğ—¶ğ—ºğ—² ğ—±ğ—¼ğ—²ğ˜€ ğ˜ğ—µğ—² ğ—®ğ—°ğ˜ğ˜‚ğ—®ğ—¹ ğ˜„ğ—¼ğ—¿ğ—¸

Images are pulled.

Containers are created.

Containers are started.

At its core, pod creation is just coordinated state changes.


![Image](https://github.com/user-attachments/assets/87866b96-5de5-4b97-927b-eef0d13c5d38)
