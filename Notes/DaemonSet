ðŸš€ hashtag#Day5 of Kubernetes â€“ DaemonSet Unlocked!

Today, I explored one of the most essential yet underrated features in Kubernetes â€“ the DaemonSet.


ðŸ” What is a DaemonSet?

A DaemonSet ensures that a specific pod runs on every node in the Kubernetes cluster.
It's commonly used for running system-level services like:

Log collectors (Fluentd, Filebeat)

Monitoring agents (Prometheus Node Exporter)

Security tools (Falco, Cilium)


As new nodes join the cluster, the DaemonSet automatically adds the required pod to that node.
When a node is removed, the pod is also removed â€” completely hands-free!

ðŸ§  Real-World Analogy

Imagine you're running a delivery company.
Each city (node) must have one local warehouse (pod) to manage orders and logistics.
You donâ€™t want two warehouses in one city â€” just one per city is perfect.
And if your company expands into a new city? A warehouse is automatically built there.

This is exactly how DaemonSet works:

> One pod per node â€“ ensuring every area is covered with essential infrastructure.


ðŸ”„ DaemonSet vs StatefulSet

ðŸ“Œ Pod Count
DaemonSet: One pod runs on every node
StatefulSet: You define how many pods (replicas) you want


ðŸ“Œ Identity
DaemonSet: Pods are identical, no fixed name
StatefulSet: Each pod has a unique identity (like pod-0, pod-1...)

ðŸ“Œ Use Case
DaemonSet: Perfect for system-level agents like log shippers, monitoring tools
StatefulSet: Used for stateful apps like MySQL, Kafka, Cassandra

ðŸ“Œ Storage
DaemonSet: Usually ephemeral or shared
StatefulSet: Each pod has a dedicated persistent volume

ðŸ“Œ Deployment Order
DaemonSet: No strict order, runs wherever needed
StatefulSet: Pods start and stop in a defined, sequential order

âœ… Use DaemonSet when something needs to run everywhere (like surveillance cameras on every floor).
âœ… Use StatefulSet when apps need consistent identity, storage, and order.
