ğŸš€ ğ—ğ˜‚ğ—¯ğ—²ğ—¿ğ—»ğ—²ğ˜ğ—²ğ˜€ ğ——ğ—²ğ—½ğ—¹ğ—¼ğ˜†ğ—ºğ—²ğ—»ğ˜ ğŸš€

ğŸ§± ğ—ªğ—µğ˜† ğ——ğ—²ğ—½ğ—¹ğ—¼ğ˜†ğ—ºğ—²ğ—»ğ˜ ğ—¶ğ—» ğ—ğ˜‚ğ—¯ğ—²ğ—¿ğ—»ğ—²ğ˜ğ—²ğ˜€?
ğŸ’¥ Deployment in K8s brings zero-downtime updates, rollbacks, version control, and scaling (manual or automatic).
âœ… It combines all features of ReplicaSet with bonus features like:
âœ… Image update without downtime
âœ… Historical version tracking & rollback
âœ… Pause updates (temporarily)
âœ… Manual & auto-scaling via HPA/VPA
âœ… Rolling update strategy ensures always-on apps

ğŸŒ€ Deployment â¡ï¸ ReplicaSet â¡ï¸ Pods â¡ï¸ Containers
ğŸ—‘ï¸ Delete Deployment â¡ï¸ All underlying resources are deleted

ğŸ”§ ğ—£ğ—¿ğ—®ğ—°ğ˜ğ—¶ğ—°ğ—®ğ—¹ ğ—¦ğ—²ğ˜ğ˜‚ğ—½:
Launch EC2 with IAM role
Install: Docker ğŸ³, AWS CLI (if needed), kOps, kubectl
Write Deployment Manifest file and service manifest file
 kubectl create -f deploy.yml
 kubectl get deploy
 kubectl get rs
 kubectl get po
 kubectl describe deploy <deployment-name>
ğŸ‘‰ Add svc.yml to expose the app
 kubectl create -f svc.yml
 kubectl get svc
ğŸ”— Access the app via the DNS from the service

ğŸ” ğ—œğ—ºğ—®ğ—´ğ—² ğ—¨ğ—½ğ—±ğ—®ğ˜ğ—² ğ—£ğ—¿ğ—¼ğ—°ğ—²ğ˜€ğ˜€:
Write & push updated code to GitHub
Create a Dockerfile & build Docker image
Scan image â¡ï¸ Push to Docker Hub
Update image in K8s (two ways):
âœ… Via manifest
âœ… use CLI:
 kubectl set image deploy <deployment> <container>=<image>

ğŸ”™ ğ—¥ğ—¼ğ—¹ğ—¹ğ—¯ğ—®ğ—°ğ—¸ğ˜€ & ğ—©ğ—²ğ—¿ğ˜€ğ—¶ğ—¼ğ—» ğ—–ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹
Track and manage your app versions:
 kubectl rollout history deploy <deployment>
 kubectl rollout undo deploy <deployment> --to-revision=<version-num>
 kubectl rollout status deploy <deployment>
 kubectl get rs
ğŸ“ Rolling updates keep only the current version's pods running. Old RS exists, but pods are recycled.
ğŸ‘ï¸ Use -w to watch RS changes live:
 kubectl get rs -w
