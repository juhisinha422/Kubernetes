Kubernetes Learning from Scratch

â€“ Day 10 (Journey to CKA)

Todayâ€™s Topic: Deployment

ðŸ‘‰ A Deployment in Kubernetes is a higher-level abstraction built on top of ReplicaSets.
It not only ensures that the desired number of Pods are running (like a ReplicaSet) but also allows rolling updates, rollbacks, and version control of your applications.

ðŸ”¹ Key Features of Deployment
Declarative Updates â†’ You define what you want, Kubernetes ensures it.
Rolling Updates â†’ Deploy new versions without downtime.
Rollback Support â†’ Quickly revert to the previous stable version if something breaks.
Self-healing â†’ Automatically replaces failed or unhealthy Pods.
Scalability â†’ Easily scale apps up/down by changing replica count.

Kubernetes will gradually replace old Pods with new ones.
If something fails, you can rollback using:
kubectl rollout undo deployment nginx-deploy

ðŸ”„ ReplicaSet vs Deployment
ðŸ“Œ ReplicaSet â†’ Ensures Pod availability.
ðŸ“Œ Deployment â†’ Manages ReplicaSets, handles updates & rollbacks.

ðŸ‘‰ Think of Deployment as the manager ðŸ‘¨ðŸ’¼, and ReplicaSet as the worker ðŸ‘·.

ðŸ”¹ Important Note
In real-world Kubernetes, you almost always use Deployments (not ReplicaSets directly).
They are the go-to resource for running stateless applications in production.
ðŸ‘‰ In short, Deployment = Smart Pod Manager ðŸ¤–
It not only keeps Pods running but also ensures smooth upgrades, rollbacks, and scaling.
