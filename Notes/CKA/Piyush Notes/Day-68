Day 68
Revisiting Argo CD | GitOps in Practice
After working extensively with Kubernetes, one lesson becomes very clear:
deployment is easy dependency management is not.

Today, I revisited Argo CD and went deeper into how GitOps actually works at scale.

Key learnings:
ğŸ”¹ Argo CD Application = atomic deployment unit
It manages a group of loosely coupled Kubernetes resources, not just manifests.
ğŸ”¹ Ordering matters
CRDs, controllers, and dependent services require:
Sync Waves
App-of-Apps pattern
Progressive Syncs (ApplicationSets)
ğŸ”¹ Cross-application dependencies are real
There is no â€œone-clickâ€ solution. You choose based on system design:
Eventual consistency
App-of-Apps (great for bootstrapping)
Progressive Syncs for controlled rollouts
ğŸ”¹ Health checks are non-negotiable
Readiness & Liveness probes
Argo CD Application health checks
Without them, automation is blind.
ğŸ”¹ GitOps is more than YAML
Repo structure, retry strategies, sync options, and installation choices (Helm + Kustomize) directly impact reliability and scalability.
