Day 7 â€“ Container Runtime 

ğŸš€ Kubernetes Learning from Scratch
â€“ Day 7 (Journey to CKA)

Todayâ€™s Topic: Container Runtime

If Kubelet is the Captain ğŸš¢ and Kube-Proxy is the Traffic Controller ğŸš¦, then the Container Runtime is the Engine âš™ï¸ that actually runs the containers on the node.

ğŸ”¹ What is a Container Runtime?
A software responsible for pulling images and running containers.
Kubernetes doesnâ€™t run containers directly â†’ it asks the container runtime to do it.
Common runtimes: Docker (earlier), containerd, CRI-O.
ğŸ”¹ Role in Kubernetes
Kubelet gives the PodSpec â†’ Container Runtime executes it.
Pulls container images from registries (e.g., DockerHub, ECR, GCR).
Starts & stops containers.
Provides resource isolation (CPU, Memory) using Linux features like cgroups & namespaces.
ğŸ”¹ Important Note
Kubernetes used Docker before, but now prefers containerd or CRI-O (via the Container Runtime Interface â€“ CRI).
Docker is still popular with developers, but Kubernetes itself doesnâ€™t need Docker to run.
ğŸ“Œ Example:
1ï¸âƒ£ You apply a Pod YAML (kubectl apply -f pod.yaml).
2ï¸âƒ£ Scheduler decides the node.
3ï¸âƒ£ Kubelet asks the container runtime â†’ â€œPlease pull nginx:latest and run it.â€
4ï¸âƒ£ Runtime pulls the image, runs the container, and reports status back to kubelet.
ğŸ‘‰ In short, Container Runtime = The Engine âš™ï¸ that powers your Pods.
Without it, Kubernetes is just an orchestrator with no execution power.
