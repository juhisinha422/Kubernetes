ğ—ğ˜‚ğ—¯ğ—²ğ—¿ğ—»ğ—²ğ˜ğ—²ğ˜€ ğ—–ğ—¥ğ——ğ˜€ â€“ ğ—˜ğ˜…ğ˜ğ—²ğ—»ğ—± ğ—ğŸ´ğ˜€ ğ—Ÿğ—¶ğ—¸ğ—² ğ—® ğ—£ğ—¿ğ—¼

What if Kubernetes doesnâ€™t support your resource type out of the box? No problem â€” just create your own! Thatâ€™s where Custom Resource Definitions (CRDs) come in. ğŸ”§

ğŸ”¹ ğ—ªğ—µğ—®ğ˜ ğ—¶ğ˜€ ğ—® ğ—–ğ—¥ğ——?
A Custom Resource Definition (CRD) allows you to define your own API objects in Kubernetes â€” making the platform extensible beyond built-in types like Pods, Services, or Deployments.

ğŸ’¡ CRDs = â€œMake Kubernetes understand your kind of object.â€

ğŸ§  ğ—ªğ—µğ˜† ğ—¨ğ˜€ğ—² ğ—–ğ—¥ğ——ğ˜€?
âœ… Add domain-specific logic (e.g., ğ˜‰ğ˜¢ğ˜¤ğ˜¬ğ˜¶ğ˜±, ğ˜‹ğ˜¢ğ˜µğ˜¢ğ˜£ğ˜¢ğ˜´ğ˜¦, ğ˜Šğ˜­ğ˜¶ğ˜´ğ˜µğ˜¦ğ˜³)
âœ… Build custom operators/controllers
âœ… Treat custom resources like first-class citizens in kubectl
âœ… Power automation and GitOps workflows

ğŸ› ï¸ ğ—¥ğ—²ğ—®ğ—¹-ğ—ªğ—¼ğ—¿ğ—¹ğ—± ğ—¨ğ˜€ğ—² ğ—–ğ—®ğ˜€ğ—²ğ˜€:
ğŸ”¸ Define a ğ˜’ğ˜¢ğ˜§ğ˜¬ğ˜¢ğ˜Šğ˜­ğ˜¶ğ˜´ğ˜µğ˜¦ğ˜³ object for deploying Kafka
ğŸ”¸ Use ğ˜Šğ˜¦ğ˜³ğ˜µğ˜”ğ˜¢ğ˜¯ğ˜¢ğ˜¨ğ˜¦ğ˜³ CRDs for auto-renewing TLS certs
ğŸ”¸ Integrate ğ˜ˆğ˜³ğ˜¨ğ˜°ğ˜Šğ˜‹, ğ˜ğ˜´ğ˜µğ˜ªğ˜°, ğ˜—ğ˜³ğ˜°ğ˜®ğ˜¦ğ˜µğ˜©ğ˜¦ğ˜¶ğ˜´, etc. â€” all CRD-powered
ğŸ”¸ Build your own controller to reconcile custom resources

âš™ï¸ ğ—•ğ—²ğ˜€ğ˜ ğ—£ğ—¿ğ—®ğ—°ğ˜ğ—¶ğ—°ğ—²ğ˜€:
âœ” Design your CRD schema with OpenAPI v3 validation
âœ” Document your CRs just like APIs
âœ” Add status fields for observability
âœ” Combine with controllers to bring your CRDs to life (aka the Operator pattern)

ğŸ¯ CRDs unlock the true power of Kubernetes as a platform. If you can imagine a resource, you can build it into your cluster. Welcome to the future of extensibility. ğŸš€
