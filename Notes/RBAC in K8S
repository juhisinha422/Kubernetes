ğŸŒˆ ğŸ”‘ ğ—¥ğ—•ğ—”ğ—– ğ—¶ğ—» ğ—ğ˜‚ğ—¯ğ—²ğ—¿ğ—»ğ—²ğ˜ğ—²ğ˜€: ğ—¥ğ—¼ğ—¹ğ—²-ğ—•ğ—®ğ˜€ğ—²ğ—± ğ—”ğ—°ğ—°ğ—²ğ˜€ğ˜€ ğ—–ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ ğ——ğ—²ğ—ºğ˜†ğ˜€ğ˜ğ—¶ğ—³ğ—¶ğ—²ğ—±
When you're managing a shared Kubernetes environment, it's critical to control access precisely, and that's where Role-Based Access Control (RBAC) comes in.
ğŸ›¡ï¸ ğ–ğ¡ğ² ğ‘ğğ€ğ‚ ğŒğšğ­ğ­ğğ«ğ¬
RBAC defines who can access which Kubernetes resources, and what actions they can perform. Whether you're running a multi-team platform or a single cluster, itâ€™s your first line of defence.
ğŸ§‘ğŸ’» Real-world case: You want developers to view pods, but not modify or delete them? RBAC is how you enforce that.
ğŸ”§ ğ„ğ¬ğ¬ğğ§ğ­ğ¢ğšğ¥ ğğ®ğ¢ğ¥ğğ¢ğ§ğ  ğğ¥ğ¨ğœğ¤ğ¬
1ï¸âƒ£ Role â€“ Defines permissions on namespaced resources (e.g., list, get).
2ï¸âƒ£ RoleBinding â€“ Connects a Role with a subject (user/service account).
3ï¸âƒ£ ClusterRole â€“ Similar to Role, but works across all namespaces.
4ï¸âƒ£ ClusterRoleBinding â€“ Assigns ClusterRole at the cluster level.
ğŸ” ğ”ğ§ğğğ«ğ¬ğ­ğšğ§ğ ğ­ğ¡ğ ğ€ğ®ğ­ğ¡ ğğ¢ğ©ğğ¥ğ¢ğ§ğ (see image-1)
âœ… Authentication â€“ Confirms your identity.
âœ… Authorisation â€“ Checks if youâ€™re permitted to perform the requested action.
âœ… Admission Controller â€“ Validates the request before execution.
ğŸ§ª ğ’ğ­ğğ©-ğğ²-ğ’ğ­ğğ© ğ‡ğšğ§ğğ¬-ğğ§: ğ‘ğğ€ğ‚ ğˆğ§ ğ€ğœğ­ğ¢ğ¨ğ§
ğŸ” Step 1: Generate a New User Certificate
openssl genrsa -out dileep.key 2048
openssl req -new-key dileep.key -out, dileep.csr -subj "/CN=dileep/O=group1"
openssl x509 -req -in dileep.csr -CA ~/.minikube/ca.crt -CAkey ~/.minikube/ca.key -CAcreateserial -out dileep.crt -days 500
ğŸ”§ Step 2: Add User Context
kubectl config set-credentials dileep --client-certificate=dileep.crt --client-key=dileep.key
kubectl config set-context my-context-- cluster=minikube-- user=dileep
kubectl config use-context my-context
ğŸ“ Step 3: Define Role & RoleBinding (see image-2, image-3)
Create YAMLs to:
Grant read-only access to pods in a specific namespace
Bind those permissions to the user
ğŸŒ Step 4: Set up Cluster-Wide Access (see image 4)
Use ClusterRole and ClusterRoleBinding when global access is necessary.
ğŸ’¡ ğ“ğ¢ğ©ğ¬ ğ…ğ¨ğ« ğ’ğšğŸğğ« ğ‘ğğ€ğ‚
ğŸ”’ Stick to least privilege principles
ğŸ¯ Reuse roles across teams by grouping logical permissions
ğŸ§ª Use kubectl auth can-i to test access rules
ğŸš§ Lock down critical resources with tight permissions
ğŸ§¹ Periodically audit and prune outdated RoleBindings
âœ… ğ•ğğ«ğ¢ğŸğ² ğ“ğ¡ğ ğ’ğğ­ğ®ğ©
Switch to the custom user context and try to:
View allowed resources (e.g., kubectl get pods)
Attempt forbidden actions and verify the denial
ğŸ“Œ ğ‚ğ¨ğ§ğœğ¥ğ®ğ¬ğ¢ğ¨ğ§
By mastering RBAC, youâ€™re not just enforcing security â€” you're enabling a safe and scalable Kubernetes experience across your entire organisation.
ğŸ” Secure clusters. Empower users. Stay compliant.
