How Kubernetes Works from Start to Finish â€” A Step-by-Step GuideðŸš€

1. You set up a Kubernetes cluster â€“ it consists of a control plane and worker nodes.

2. You define your application using YAML files â€“ typically with Deployment, Service, ConfigMap, etc.

3. You apply the YAML using kubectl apply -f, the request goes to the API Server, the central control point.

4. Kubernetes checks the request to decide what to do:
a. Create a new object like a Pod or Deployment?
b. Update or delete an existing object?
c. Trigger a controller to take action? etc.,

5. The API server stores the objectâ€™s spec in etcd, the clusterâ€™s database.

6. The appropriate controller sees the new spec â€“ like a ReplicaSet controller watching for new Deployments.

7. The controller creates the necessary resources â€“ for example, telling the scheduler to place new Pods.

8. The scheduler picks a suitable node for each Pod â€“ based on resource availability and scheduling rules.

9. The Pod spec is sent to the nodeâ€™s Kubelet â€“ it requests the container runtime to start the container.

10. The container runtime pulls the image, creates the container, and runs it inside the Pod.

11. The CNI plugin assigns a network identity â€“ the Pod gets an IP address and joins the cluster network.

12. kube-proxy sets up routing rules â€“ allowing Services to forward traffic to healthy Pods.

13. The Kubelet reports Pod status back to the API server â€“ used to track readiness and health.

14. If a Pod crashes or is deleted, the controller notices and recreates it â€“ keeping the system in sync.

15. This entire loop keeps running â€“ Kubernetes constantly watches and reconciles to match the desired state.
