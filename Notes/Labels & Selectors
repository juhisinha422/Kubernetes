ğŸš€ ğŠğ®ğ›ğğ«ğ§ğğ­ğğ¬ ğ‹ğğšğ«ğ§ğ¢ğ§ğ  ğ‰ğ¨ğ®ğ«ğ§ğğ² â€“ ğƒğšğ² 4: ğ”ğ§ğğğ«ğ¬ğ­ğšğ§ğğ¢ğ§ğ  ğ‹ğšğ›ğğ¥ğ¬ & ğ’ğğ¥ğğœğ­ğ¨ğ«ğ¬ ğŸğ¨ğ« ğ„ğŸğŸğ¢ğœğ¢ğğ§ğ­ ğ‘ğğ¬ğ¨ğ®ğ«ğœğ ğŒğšğ§ğšğ ğğ¦ğğ§ğ­! ğŸ¯ğŸ”
Today, I explored one of the core concepts in Kubernetes â€“ Labels and Selectors, which play a crucial role in organizing, identifying, and managing resources efficiently within a Kubernetes cluster.

ğŸ“Œ ğ—ªğ—µğ—®ğ˜ ğ—®ğ—¿ğ—² ğ—Ÿğ—®ğ—¯ğ—²ğ—¹ğ˜€ & ğ—¦ğ—²ğ—¹ğ—²ğ—°ğ˜ğ—¼ğ—¿ğ˜€?

ğŸ· ğ—Ÿğ—®ğ—¯ğ—²ğ—¹ğ˜€
hashtag#Labels are key-value pairs attached to Kubernetes objects (such as Pods, Services, Deployments, and ReplicaSets). They help in categorizing, filtering, and grouping resources based on specific attributes. Unlike names and UIDs, which are unique, labels provide a flexible way to organize resources logically.

âœ… Example of a label:
metadata:
 labels:
 app: web
 env: production

ğŸ” ğ—¦ğ—²ğ—¹ğ—²ğ—°ğ˜ğ—¼ğ—¿ğ˜€
hashtag#Selectors allow us to filter and retrieve Kubernetes resources based on specific labels. Instead of manually managing each resource, selectors enable automatic selection of relevant objects based on defined criteria.

âœ… Types of Selectors in Kubernetes:
ğŸ”¹ Equality-based selectors: Filters objects using = or != (e.g., app=web).
ğŸ”¹ Set-based selectors: Matches objects from a defined set (e.g., env in (staging, production)).

âœ… Example usage:
kubectl get pods --selector app=web

 ğŸ“‚GitHub : https://lnkd.in/gw6_PuWb

ğŸ“Œ ğ—§ğ—¼ğ—½ğ—¶ğ—°ğ˜€ ğ—–ğ—¼ğ˜ƒğ—²ğ—¿ğ—²ğ—±:

1ï¸âƒ£ ğ—¥ğ—²ğ—½ğ—¹ğ—¶ğ—°ğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—–ğ—¼ğ—»ğ˜ğ—¿ğ—¼ğ—¹ğ—¹ğ—²ğ—¿ğ˜€ & ğ——ğ—²ğ˜€ğ—¶ğ—¿ğ—²ğ—± ğ—¦ğ˜ğ—®ğ˜ğ—² ğ— ğ—®ğ—¶ğ—»ğ˜ğ—²ğ—»ğ—®ğ—»ğ—°ğ—²
Kubernetes uses Replication Controllers & ReplicaSets to maintain the desired number of running pods.
If a pod fails, Kubernetes automatically replaces it, ensuring application availability.

2ï¸âƒ£ ğ——ğ˜†ğ—»ğ—®ğ—ºğ—¶ğ—° ğ—¦ğ—°ğ—®ğ—¹ğ—¶ğ—»ğ—´ ğ˜„ğ—¶ğ˜ğ—µ ğ— ğ˜‚ğ—¹ğ˜ğ—¶ğ—½ğ—¹ğ—² ğ—–ğ—¼ğ—»ğ˜ğ—®ğ—¶ğ—»ğ—²ğ—¿ğ˜€
Explored how Horizontal Pod Autoscaler (HPA) dynamically scales pods based on CPU or memory usage.
Learned how to manage multi-container pods for more complex applications.

3ï¸âƒ£ ğ—Ÿğ—®ğ—¯ğ—²ğ—¹ğ—¶ğ—»ğ—´ & ğ—£ğ—¼ğ—± ğ—œğ—±ğ—²ğ—»ğ˜ğ—¶ğ—³ğ—¶ğ—°ğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—³ğ—¼ğ—¿ ğ—•ğ—²ğ˜ğ˜ğ—²ğ—¿ ğ— ğ—®ğ—»ğ—®ğ—´ğ—²ğ—ºğ—²ğ—»ğ˜
Labels allow Kubernetes to group, filter, and manage pods efficiently.
Used kubectl get pods --selector env=production to query resources dynamically.
Services use selectors to route traffic automatically to the right set of pods.

4ï¸âƒ£ ğ—¨ğ˜€ğ—¶ğ—»ğ—´ ğ—¸ğ˜‚ğ—¯ğ—²ğ—°ğ˜ğ—¹ ğ—°ğ—¿ğ—²ğ—®ğ˜ğ—² ğ˜ƒğ˜€. ğ—¸ğ˜‚ğ—¯ğ—²ğ—°ğ˜ğ—¹ ğ—®ğ—½ğ—½ğ—¹ğ˜† ğ—³ğ—¼ğ—¿ ğ—–ğ—¼ğ—»ğ—³ğ—¶ğ—´ğ˜‚ğ—¿ğ—®ğ˜ğ—¶ğ—¼ğ—» ğ—¨ğ—½ğ—±ğ—®ğ˜ğ—²ğ˜€
kubectl create is used for new resources but does not update existing ones.
kubectl apply follows a declarative approach, allowing incremental updates to existing resources.
