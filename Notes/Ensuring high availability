Ensuring High Availability in Kubernetes with Pod Resources & Disruption Budgets

In the world of cloud-native applications, resilience and availability are non-negotiable. As engineers, our job doesnâ€™t end with getting things to run â€” itâ€™s about ensuring they stay running, especially under pressure.
Recently, I revisited a real-world Kubernetes scenario around Pod Resource Management and Pod Disruption Budgets (PDBs). Here's a breakdown of what I learned, applied, and why it matters in production environments.

ğŸ”§ Part 1: Resource Requests & Limits â€“ Your First Line of Defense
In Kubernetes, we can define how much CPU and memory a container requests and the maximum it can use. This is essential not just for performance, but for predictable scheduling and cost control.

resources:
 requests:
  memory: "256Mi"
  cpu: "100m"
 limits:
  memory: "512Mi"
  cpu: "500m"

âœ… What This Means:
   1. Requests: The minimum guaranteed resources your pod will get. Kubernetes uses this during scheduling.
   2. Limits: The maximum resources your pod is allowed to use. Exceed it,  and the pod could be throttled or killed (OOMKilled).
Setting these ensures:
  1.  Your pod wonâ€™t overconsume and starve other workloads.
   2. Kubernetes can make smart scheduling decisions.
   3. Cost is managed, and nodes arenâ€™t overprovisioned.

ğŸ›¡ï¸ Part 2: PodDisruptionBudgets â€“ Guarding Availability During Chaos
What happens when you drain a node, update your deployment, or autoscaling kicks in?
Thatâ€™s where PodDisruptionBudgets (PDBs) shine. They act as a safety layer that prevents too many pods from being voluntarily evicted at once, helping maintain application uptime.
Example PDB:
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
 name: critical-service-pdb
spec:
 minAvailable: 2
 selector:
  matchLabels:
   app: critical-service

ğŸ” What This Does:
Ensures at least 2 pods are always running and ready.
If Kubernetes wants to evict more and doing so drops the number of available pods below 2 â€” it blocks that disruption.
This is cluster-wide (not node-specific), and applies only to voluntary disruptions â€” like rolling updates, node upgrades, or manual drains.
ğŸ§  Common Misconception: Will Kubernetes Move the Pods?
Many think Kubernetes will "move" or "protect" specific pods when using a PDB. Here's the truth:
Kubernetes does not move pods â€” it evicts, and your controller (like a Deployment) recreates them on available nodes.
If PDBs are configured correctly, at least the minimum number of pods will always stay active â€” giving you fault tolerance and high availability during planned disruptions.
ğŸ§© Wrapping It All Together
By combining:
Thoughtful resource requests and limits
Well-planned PDBs
You can:
 âœ… Protect your application during rollouts and node drains
 âœ… Avoid OOM kills and CPU throttling
 âœ… Ensure your service remains highly available â€” even under stress
ğŸ¯ Final Thought
High availability isnâ€™t a feature â€” itâ€™s a discipline.

