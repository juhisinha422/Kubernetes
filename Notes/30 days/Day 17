ğŸš¦ ğ——ğ—®ğ˜† ğŸ­ğŸ³: ğ—Ÿğ—¶ğ˜ƒğ—²ğ—»ğ—²ğ˜€ğ˜€, ğ—¥ğ—²ğ—®ğ—±ğ—¶ğ—»ğ—²ğ˜€ğ˜€ & ğ—¦ğ˜ğ—®ğ—¿ğ˜ğ˜‚ğ—½ ğ—£ğ—¿ğ—¼ğ—¯ğ—²ğ˜€ â€“ ğ—›ğ—²ğ—®ğ—¹ğ˜ğ—µ ğ—–ğ—µğ—²ğ—°ğ—¸ğ˜€ ğ—¶ğ—» ğ—ğ˜‚ğ—¯ğ—²ğ—¿ğ—»ğ—²ğ˜ğ—²ğ˜€
Welcome to Day 17 of our hashtag#Kubernetes learning series! After getting our hands dirty with persistent storage, today we're focusing on keeping our containers healthy and production-ready with Kubernetes health checks â€” specifically, Liveness, Readiness, and Startup Probes.

ğŸ©º ğ—ªğ—µğ˜† ğ——ğ—¼ ğ—£ğ—¿ğ—¼ğ—¯ğ—²ğ˜€ ğ— ğ—®ğ˜ğ˜ğ—²ğ—¿?
Just because a container is running doesnâ€™t mean itâ€™s healthy or ready to serve traffic. Apps can hang, crash silently, or take time to start up â€” and Kubernetes needs a way to detect that.

Enter: Probes â€” Kubernetesâ€™ built-in mechanism to monitor container health and respond automatically.

ğŸ” ğ—Ÿğ—¶ğ˜ƒğ—²ğ—»ğ—²ğ˜€ğ˜€ ğ—£ğ—¿ğ—¼ğ—¯ğ—²
Checks if the app is still functioning. If it fails, Kubernetes restarts the container. This is your safety net for hung or crashed processes.

âœ… ğ—¥ğ—²ğ—®ğ—±ğ—¶ğ—»ğ—²ğ˜€ğ˜€ ğ—£ğ—¿ğ—¼ğ—¯ğ—²
Checks if the app is ready to handle requests. If this fails, Kubernetes removes the pod from the load balancer so it doesnâ€™t serve traffic until itâ€™s actually ready.

ğŸš¦ ğ—¦ğ˜ğ—®ğ—¿ğ˜ğ˜‚ğ—½ ğ—£ğ—¿ğ—¼ğ—¯ğ—² (ğ—¢ğ—³ğ˜ğ—²ğ—» ğ—¢ğ˜ƒğ—²ğ—¿ğ—¹ğ—¼ğ—¼ğ—¸ğ—²ğ—±!)
Some applications take time to fully initialize â€” maybe due to complex bootstrapping or dependency loading. If you start using liveness probes too early, Kubernetes might restart the container before it ever finishes starting up.

The startup probe solves this. It tells Kubernetes, â€œGive my app a chance to get going.â€ While this probe is running, liveness and readiness checks are paused. Once the startup probe succeeds, the other probes take over.

ğŸ§  ğ—ğ—²ğ˜† ğ——ğ—¶ğ—³ğ—³ğ—²ğ—¿ğ—²ğ—»ğ—°ğ—²ğ˜€
 â€¢ Use startup probes to delay health checks during long app initializations.
 â€¢ Use liveness probes to catch stuck containers and recover automatically.
 â€¢ Use readiness probes to control traffic routing based on app readiness.

Together, these three probes give you fine-grained control over application health and help build resilient, production-grade systems.
